<p>Ding ding. Fight!</p>
<p>It’s 2016, and this age old question needs an updated response: Node or Ruby?</p>
<p>Obviously, the answer is it depends on what you need, and what your requirements are and blah blah blah (useless right?). What’s interesting about this question in 2016 is not so much how Node and Ruby have changed, but how everything else has.</p>
<p>From a purely technical standpoint, Node is the winner. Javascript, the Node language, is faster than Ruby at handling general computations (although it has difficulty with intense computational tasks like modifying images). The reason Node is faster is because it’s more efficient at sending packages to be computed.</p>
<p>This efficiency comes at a cost: Node is more complex than Ruby. Not impossibly more complex, but enough that it will slow down development time. Node has definitely improved over the years as promises have toppled callbacks (two ways of dealing with the asynchronous code that powers efficient packaging), but it will never be as simple or easy to learn as Ruby.</p>
<p>Simplicity is a problem, because simplicity is money for developers. If you’re coding with a ubiquitous language, your employees will not cost as much. Thanks to the recent explosion of coding schools specializing in Ruby-on-Rails (RoR) education, the cost of a Ruby developer is almost certainly less than the cost of a Node developer. The skill levels won’t be the same, but if the application is simple enough, it might not matter.</p>
<p>Aside from the advantages and disadvantages of the actual languages, the frameworks surrounding Node and Ruby have a significant impact on development time. Ruby has Rails, and Rails has not changed much over the last 10 years. There’s certainly been an uptake in fusing Node build tools with Rails, but for the most part RoR has stayed the same. There are other frameworks for Ruby, but Rails is clearly king of Ruby.</p>
<p>Node has no king, Node needs no king.</p>
<p>Just kidding, Node definitely needs a dominant framework to facilitate development, and it just isn’t getting one. For a lot of reasons, but namely because there are too many moving parts to Node. Take Sails for instance, the Node Rails imitator. It was built on Grunt, which is a deprecated Node build tool. Its ORM, Watermark, has had both gaping utility and performance issues thanks to its all-in-one capabilities (NOSQL and SQL). It has an Express based server, which is still relevant today, but if KOA continues to gain traction in the Node community, this could become another deprecated component.</p>
<p>That’s the problem with a Node backend. When we pick technologies for different projects, one of the considerations is how it will hold up in the future. It used to be that Node was the future-proof technology, but it’s changing so quickly that the iterations of Node today are obsolete in just a few years, if not months. Dare I say, Ruby is more future-proof.</p>
<p>The only way to ensure the future of a Node application at this time is to go frameworkless, but this is not idea. Boilerplates and package files can speed up the start time for frameworkless applications, but they’re no substitute for an actual framework. Longer development cycles are inevitable.</p>
<p>There’s also a question of whether Node will be the backend technology of choice in the future. A few years ago, Node was just about the only relevant future backend technology in conversations, but with Google’s Go, with PHP7’s ridiculous performance boost, and with all the other players in the backend market, it’s not as certain. As of today, Node has never been more popular, but other options exist, and will continue to build off of Node’s weaknesses.</p>
<p>For myself, I’m building in Node these days. As a developer, I want to be working with the best technologies, and Node has the momentum right now. As an MBA graduate, I can’t help but ponder, do I want a fast application, or do I want to build applications fast?</p>